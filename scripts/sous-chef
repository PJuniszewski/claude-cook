#!/usr/bin/env node

/**
 * Sous Chef CLI
 *
 * Background monitoring tool for cook artifacts.
 * Detects uncooked changes, drift, and analyzes post-mortems.
 *
 * Usage:
 *   sous-chef monitor [--since <commit>] [--until <commit>]
 *   sous-chef drift <artifact> [--range <git-range>] [--since <date>]
 *   sous-chef postmortem <artifact> [--incidents "issue1,issue2"] [--template]
 *   sous-chef suggest [--since <date>]
 */

const path = require('path');
const fs = require('fs');

// Load modules
const { analyzeCommits, formatChangeReport } = require('./lib/changeMonitor');
const { analyzeDrift, formatDriftReport } = require('./lib/driftDetector');
const { generatePostMortem, formatPostMortemReport, generateOutcomeTemplate, extractPreMortem } = require('./lib/postMortem');
const { loadIndex, buildIndex } = require('./lib/indexer');

// Parse command line arguments
function parseArgs(args) {
  const result = {
    command: null,
    positional: [],
    options: {}
  };

  let i = 0;
  while (i < args.length) {
    const arg = args[i];

    if (arg.startsWith('--')) {
      const key = arg.slice(2);
      const nextArg = args[i + 1];

      if (nextArg && !nextArg.startsWith('--')) {
        result.options[key] = nextArg;
        i += 2;
      } else {
        result.options[key] = true;
        i += 1;
      }
    } else if (!result.command) {
      result.command = arg;
      i += 1;
    } else {
      result.positional.push(arg);
      i += 1;
    }
  }

  return result;
}

// Show help
function showHelp() {
  console.log(`
Sous Chef - Background monitoring for cook artifacts

USAGE:
  sous-chef <command> [options]

COMMANDS:
  monitor     Detect commits with uncooked sensitive changes
  drift       Compare implementation against artifact plan
  postmortem  Analyze pre-mortem predictions vs outcomes
  suggest     Surface patterns that should be cooked

EXAMPLES:
  # Check recent commits for uncooked changes
  sous-chef monitor

  # Check specific range
  sous-chef monitor --since HEAD~20

  # Check drift for an artifact
  sous-chef drift cook/feature.2026-01-20.cook.md

  # Check drift against specific git range
  sous-chef drift cook/feature.cook.md --range main..feature-branch

  # Generate post-mortem analysis
  sous-chef postmortem cook/feature.cook.md

  # Analyze with known incidents
  sous-chef postmortem cook/feature.cook.md --incidents "timeout error,memory leak"

  # Generate post-mortem template
  sous-chef postmortem cook/feature.cook.md --template

  # Get suggestions for uncooked patterns
  sous-chef suggest

OPTIONS:
  --since <ref>       Start commit/date for analysis
  --until <ref>       End commit (default: HEAD)
  --range <range>     Git commit range (e.g., main..feature)
  --incidents <list>  Comma-separated list of incidents
  --template          Generate outcome template
  --help              Show this help
`);
}

// Monitor command
function runMonitor(options) {
  console.log('Analyzing commits for uncooked changes...');

  const results = analyzeCommits({
    since: options.since || 'HEAD~10',
    until: options.until || 'HEAD'
  });

  console.log(formatChangeReport(results));
}

// Drift command
function runDrift(artifactPath, options) {
  if (!artifactPath) {
    console.error('Error: Artifact path required');
    console.error('Usage: sous-chef drift <artifact.cook.md>');
    process.exit(1);
  }

  // Resolve artifact path
  let resolvedPath = artifactPath;
  if (!fs.existsSync(resolvedPath)) {
    // Try cook/ directory
    resolvedPath = path.join('cook', artifactPath);
  }
  if (!fs.existsSync(resolvedPath)) {
    console.error(`Error: Artifact not found: ${artifactPath}`);
    process.exit(1);
  }

  console.log(`Analyzing drift for: ${resolvedPath}`);

  try {
    const analysis = analyzeDrift(resolvedPath, {
      range: options.range,
      since: options.since
    });

    console.log(formatDriftReport(analysis));
  } catch (err) {
    console.error(`Error: ${err.message}`);
    process.exit(1);
  }
}

// Post-mortem command
function runPostMortem(artifactPath, options) {
  if (!artifactPath) {
    console.error('Error: Artifact path required');
    console.error('Usage: sous-chef postmortem <artifact.cook.md>');
    process.exit(1);
  }

  // Resolve artifact path
  let resolvedPath = artifactPath;
  if (!fs.existsSync(resolvedPath)) {
    resolvedPath = path.join('cook', artifactPath);
  }
  if (!fs.existsSync(resolvedPath)) {
    console.error(`Error: Artifact not found: ${artifactPath}`);
    process.exit(1);
  }

  try {
    if (options.template) {
      // Generate template only
      const scenarios = extractPreMortem(resolvedPath);
      console.log(generateOutcomeTemplate(scenarios));
      return;
    }

    let outcome = null;
    if (options.incidents) {
      outcome = {
        incidents: options.incidents.split(',').map(i => i.trim()),
        issues: [],
        notes: ''
      };
    }

    const report = generatePostMortem(resolvedPath, outcome);
    console.log(formatPostMortemReport(report));
  } catch (err) {
    console.error(`Error: ${err.message}`);
    process.exit(1);
  }
}

// Suggest command
function runSuggest(options) {
  console.log('Analyzing codebase for patterns that should be cooked...');
  console.log('');

  // Load index
  let index = loadIndex('.claude/data/cook-index.json');
  if (!index) {
    index = buildIndex('cook');
  }

  const artifacts = index.artifacts || [];

  // Collect all touched files from artifacts
  const cookedFiles = new Set();
  for (const a of artifacts) {
    if (a.filesTouched) {
      a.filesTouched.forEach(f => cookedFiles.add(f.toLowerCase()));
    }
  }

  // Get recent commits
  const { getCommits, getCommitFiles } = require('./lib/changeMonitor');
  const since = options.since || 'HEAD~30';
  const commits = getCommits(since, 'HEAD');

  // Count file changes
  const fileChanges = new Map();
  for (const commit of commits) {
    const files = getCommitFiles(commit.hash);
    for (const file of files) {
      const count = fileChanges.get(file) || 0;
      fileChanges.set(file, count + 1);
    }
  }

  // Find hot files (changed 3+ times) that weren't cooked
  const hotUncooked = [];
  for (const [file, count] of fileChanges) {
    if (count >= 3 && !cookedFiles.has(file.toLowerCase())) {
      hotUncooked.push({ file, count });
    }
  }

  hotUncooked.sort((a, b) => b.count - a.count);

  console.log('======================================');
  console.log('  SOUS CHEF - Suggestions');
  console.log('======================================');
  console.log('');

  if (hotUncooked.length === 0) {
    console.log('No suggestions. Your kitchen looks well-organized!');
    console.log('');
    return;
  }

  console.log(`Found ${hotUncooked.length} frequently-changed files without cook artifacts:`);
  console.log('');

  for (const { file, count } of hotUncooked.slice(0, 10)) {
    console.log(`  [${count}x] ${file}`);
  }

  if (hotUncooked.length > 10) {
    console.log(`  ... and ${hotUncooked.length - 10} more`);
  }

  console.log('');
  console.log('--------------------------------------');
  console.log('Recommendation: Consider running /cook for these areas');
  console.log('');
}

// Main
function main() {
  const args = process.argv.slice(2);
  const parsed = parseArgs(args);

  if (parsed.options.help || !parsed.command) {
    showHelp();
    process.exit(0);
  }

  switch (parsed.command) {
    case 'monitor':
      runMonitor(parsed.options);
      break;

    case 'drift':
      runDrift(parsed.positional[0], parsed.options);
      break;

    case 'postmortem':
      runPostMortem(parsed.positional[0], parsed.options);
      break;

    case 'suggest':
      runSuggest(parsed.options);
      break;

    default:
      console.error(`Unknown command: ${parsed.command}`);
      showHelp();
      process.exit(1);
  }
}

main();
